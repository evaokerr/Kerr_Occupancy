---
title: "Burrow Cleaning"
author: "Eva Kerr"
date: "2025-09-09"
output: html_document
---

```{r}
library(readr)
library(dplyr)

raw_data <- read_csv("GA Gopher Frog locations through 2024.csv")

```
```{r}
Unconfirmed <- raw_data %>%
  select(
    `Confirmed Habitat`,
    year.found,
    Latitude,
    Longitude,
    Site,
    County,
  ) %>%
  filter(County == "Camden") %>%
  filter(!`Confirmed Habitat` %in% c("dip net", "at wetland", "in wetland", "Aquatic"))

cleaning <- Unconfirmed %>%
  filter(!Longitude %in% c(-81.61694562, -81.61695873, -81.61698016, -81.617033))

write.csv(cleaning, "cleaning.csv", row.names = FALSE)

```

```{r}
wetland <- read_csv("wetland_management.csv") %>%
  select(Site, WetlandID) %>%
  filter(Site == "Ceylon WMA")
```

```{r}
library(sf)
library(dplyr)
library(stringr)

# 1) Read the full Ceylon wetlands shapefile
#    Adjust the path/filename if needed (point to the .shp file)
ceylon_all <- st_read("ceylon_all.shp")

wetland_ids <- wetland %>%
  mutate(WetlandID = str_squish(str_to_upper(as.character(WetlandID)))) %>%
  distinct(WetlandID)

# Correct version
ceylon_all <- ceylon_all %>%
  mutate(WetlandID = str_squish(str_to_upper(as.character(`Wetland.ID`))))


# 3) Keep only features whose WetlandID is in your wetland df
ceylon_subset <- ceylon_all %>%
  semi_join(wetland_ids, by = "WetlandID")
# Reorder columns: WetlandID first, then everything else
ceylon_subset <- ceylon_subset %>%
  select(WetlandID, everything())

# Drop redundant columns if they exist
ceylon_subset <- ceylon_subset %>%
  select(-any_of(c("Wetland_ID", "wetlandid")))

# Sanitize column names for shapefile
safe_names <- names(ceylon_subset) |>
  gsub("[^A-Za-z0-9_]", "_", x = _) |>  # replace spaces with underscores
  substr(1, 10) |>                      # enforce 10-char max
  make.unique(sep = "_")                # make unique if duplicates

names(ceylon_subset) <- safe_names

# Write shapefile
st_write(ceylon_subset,
         dsn = "ceylon_wetlands_subset.shp",
         delete_dsn = TRUE)

```
```{r}
library(sf)
library(dplyr)

# 1. Read wetlands (already projected in UTM 17N, good for meters!)
wetlands <- st_read("ceylon_wetlands_subset.shp")

# 2. Read cleaning points (CSV with lat/long WGS84)
cleaning <- read.csv("cleaning.csv", stringsAsFactors = FALSE)

# Add a simple ID so we can track them
cleaning$clean_id <- paste0("pt_", seq_len(nrow(cleaning)))

# Convert cleaning to sf points
cleaning_sf <- st_as_sf(cleaning,
                        coords = c("Longitude", "Latitude"),
                        crs = 4326)  # WGS84

# 3. Reproject points into same CRS as wetlands (UTM meters)
cleaning_sf <- st_transform(cleaning_sf, st_crs(wetlands))

# 4. Use the *edge* of each wetland polygon
wetlands <- st_make_valid(wetlands)                 # safety for invalid polys
wet_edge  <- st_boundary(wetlands)                  # LINESTRING boundary

# 5. Build distance matrix (wetland edge × cleaning points)
dist_matrix <- st_distance(wet_edge, cleaning_sf)   # edge-to-point distance


# 6. Find nearest, 2nd, 3rd
nearest_idx <- apply(dist_matrix, 1, order)  # indices of sorted distances

# For each wetland, get the first 3 nearest point IDs
wetlands$nearest_id_1 <- cleaning_sf$clean_id[nearest_idx[1, ]]
wetlands$nearest_id_2 <- cleaning_sf$clean_id[nearest_idx[2, ]]
wetlands$nearest_id_3 <- cleaning_sf$clean_id[nearest_idx[3, ]]

# 7. Plot: wetlands, cleaning points, and edge-to-nearest segments
plot(st_geometry(wetlands), border = "blue")
plot(st_geometry(cleaning_sf), add = TRUE, col = "red", pch = 16)

# Draw a segment from each wetland polygon to its nearest cleaning point (edge-based)
for (i in seq_len(nrow(wetlands))) {
  id1 <- wetlands$nearest_id_1[i]
  if (is.na(id1)) next

  # Find the matching point row by ID (robust to row order)
  idx <- match(id1, cleaning_sf$clean_id)
  if (is.na(idx)) next

  nearest_pt <- cleaning_sf[idx, ]

  # Segment that touches the polygon boundary and the point
  seg <- sf::st_nearest_points(wetlands[i, ], nearest_pt)
  plot(seg, add = TRUE, col = "green", lwd = 2)
  plot(sf::st_geometry(nearest_pt), add = TRUE, col = "green", pch = 17)
}



```
```{r}

library(sf)
library(dplyr)

# 1. Read wetlands (already projected in UTM 17N, good for meters!)
wetlands <- st_read("ceylon_wetlands_subset.shp")

# 2. Read burrows (points, any CRS)
burrows <- st_read("all_burrows.shp")

# Add a simple burrow ID if needed
if (!any(c("BurrowID","burrow_id","ID","id") %in% names(burrows))) {
  burrows$burrow_id <- paste0("b_", seq_len(nrow(burrows)))
  burrow_id_col <- "burrow_id"
} else {
  burrow_id_col <- intersect(names(burrows), c("BurrowID","burrow_id","ID","id"))[1]
}

# 3. Reproject burrows into same CRS as wetlands (UTM meters)
burrows <- st_transform(burrows, st_crs(wetlands))

# 4. Use the *edge* of each wetland polygon
wetlands <- st_make_valid(wetlands)
wet_edge  <- st_boundary(wetlands)

# 5. Build distance matrix (wetland edge × burrow points)
dist_matrix_b <- st_distance(wet_edge, burrows)

# 6. Find nearest, 2nd, 3rd
nearest_idx_b <- apply(dist_matrix_b, 1, order)  # indices of sorted distances

# For each wetland, get the first 3 nearest burrow IDs
wetlands$nearest_burrow_id_1 <- burrows[[burrow_id_col]][ nearest_idx_b[1, ] ]
wetlands$nearest_burrow_id_2 <- burrows[[burrow_id_col]][ nearest_idx_b[2, ] ]
wetlands$nearest_burrow_id_3 <- burrows[[burrow_id_col]][ nearest_idx_b[3, ] ]

# 7. Plot (edge-based): wetlands, burrows, and segments to nearest burrow
plot(st_geometry(wetlands), border = "blue")
plot(st_geometry(burrows), add = TRUE, col = "orange", pch = 17)   # burrow points

for (i in seq_len(nrow(wetlands))) {
  id1 <- wetlands$nearest_burrow_id_1[i]
  if (is.na(id1)) next

  # Find the matching burrow row by ID (robust to row order)
  idx <- match(id1, burrows[[burrow_id_col]])
  if (is.na(idx)) next

  nearest_pt <- burrows[idx, ]

  # Segment that touches the polygon boundary and the burrow point
  seg <- sf::st_nearest_points(wetlands[i, ], nearest_pt)
  plot(seg, add = TRUE, col = "green", lwd = 2)
  plot(sf::st_geometry(nearest_pt), add = TRUE, col = "green", pch = 17)
}


```
```{r}
library(dplyr)
library(units)

# --- Require objects from previous chunks ---
stopifnot(
  exists("wetlands"),
  exists("cleaning_sf"),
  exists("burrows"),
  exists("dist_matrix"),      # centroids x cleaning
  exists("nearest_idx"),      # order indices for cleaning
  exists("dist_matrix_b"),    # centroids x burrows
  exists("nearest_idx_b")     # order indices for burrows
)

# Wetland ID column (adjust the preference order if needed)
wet_id_col <- intersect(names(wetlands),
                        c("WetlandID","WETLANDID","wetlandid","Name","NAME","id","ID","Site","SITE"))[1]
if (is.na(wet_id_col)) {
  wetlands$.wetland_row <- seq_len(nrow(wetlands))
  wet_id_col <- ".wetland_row"
}

# Drop units for arithmetic/indexing
D_clean <- units::drop_units(as.matrix(dist_matrix))
D_burr  <- units::drop_units(as.matrix(dist_matrix_b))

row_idx <- seq_len(nrow(wetlands))

# ---- IDs (already computed; pull from existing objects) ----
clean_id_col  <- "clean_id"  # set earlier
burrow_id_col <- if ("burrow_id" %in% names(burrows)) "burrow_id" else
                 intersect(names(burrows), c("BurrowID","ID","id"))[1]

c_id_1 <- cleaning_sf[[clean_id_col]][ nearest_idx[1, ] ]
c_id_2 <- cleaning_sf[[clean_id_col]][ nearest_idx[2, ] ]
c_id_3 <- cleaning_sf[[clean_id_col]][ nearest_idx[3, ] ]

b_id_1 <- burrows[[burrow_id_col]][ nearest_idx_b[1, ] ]
b_id_2 <- burrows[[burrow_id_col]][ nearest_idx_b[2, ] ]
b_id_3 <- burrows[[burrow_id_col]][ nearest_idx_b[3, ] ]

# ---- Distances (meters) ----
c_d_1 <- D_clean[cbind(row_idx, nearest_idx[1, ])]
c_d_2 <- D_clean[cbind(row_idx, nearest_idx[2, ])]
c_d_3 <- D_clean[cbind(row_idx, nearest_idx[3, ])]

b_d_1 <- D_burr [cbind(row_idx, nearest_idx_b[1, ])]
b_d_2 <- D_burr [cbind(row_idx, nearest_idx_b[2, ])]
b_d_3 <- D_burr [cbind(row_idx, nearest_idx_b[3, ])]

# ---- Ratios (burrow / cleaning) ----
safe_ratio <- function(b, c) ifelse(is.na(b) | is.na(c) | c == 0, NA_real_, b / c)
r_1 <- safe_ratio(b_d_1, c_d_1)
r_2 <- safe_ratio(b_d_2, c_d_2)
r_3 <- safe_ratio(b_d_3, c_d_3)

# ---- Final dataframe ----
nearest_summary <- tibble::tibble(
  wetland_id = wetlands[[wet_id_col]],

  frog_m_1  = c_d_1,
  frog_m_2  = c_d_2,
  frog_m_3  = c_d_3,

  burrow_m_1    = b_d_1,
  burrow_m_2    = b_d_2,
  burrow_m_3    = b_d_3,

  ratio_b_to_f_1 = r_1,
  ratio_b_to_f_2 = r_2,
  ratio_b_to_f_3 = r_3
)

# Preview & save
print(nearest_summary, n = 10)
readr::write_csv(nearest_summary, "wetlands_nearest_cleaning_burrows_ratios.csv")

```

```{r}
# ---- Create simplified ratio dataset with Site ----
ratio_b_tof_1 <- nearest_summary %>%
  select(wetland_id, ratio_b_to_f_1) %>%
  mutate(
    ratio_b_to_f_1 = ifelse(ratio_b_to_f_1 > 1, 1, ratio_b_to_f_1),
    Site = "Ceylon WMA"
  )

# Preview
print(ratio_b_tof_1, n = 10)

# Save to CSV
readr::write_csv(ratio_b_tof_1, "ratio_b_tof_1.csv")

```

